# SNMP自定义MIB中RowStatus的应用

> 转自：[SNMP自定义MIB中RowStatus的应用](https://blog.csdn.net/zzj000/article/details/79698760)

> **应用场景**：
>
> 在管理Agent设备的配置文件的时候，难免会遇到增删查改的操作。一般的snmpget对应查，snmpset对应改，但是增删就不是简单的直接操作了，就需要用到今天的主角——RowStatus这个属性。 

> 小坑一个：RowStatus一定是和Table一起用的。 

> 传送门：[官方文档](http://www.ietf.org/rfc/rfc2579.txt)，喜欢阅读官方文档的朋友不容错过，不过是全英文的。

## 环境：

系统：Ubuntu14.04LTS 

snmp版本：net-snmp-5.7.3 

## step1. 编写MIB文件

```lua
QQMIB DEFINITIONS ::= BEGIN 

IMPORTS 
    OBJECT-GROUP, MODULE-COMPLIANCE, NOTIFICATION-GROUP
        FROM SNMPv2-CONF
    enterprises, Integer32, Unsigned32, OBJECT-TYPE, MODULE-IDENTITY,NOTIFICATION-TYPE
        FROM SNMPv2-SMI
    DisplayString, RowStatus
        FROM SNMPv2-TC;

--.1.3.6.1.4.1.73691
QQMIB OBJECT IDENTIFIER ::= { enterprises 73691 }

--.1.3.6.1.4.1.73691.1
qosTableRoot OBJECT IDENTIFIER ::= { QQMIB 1 }

--创建一个table，必须以xxxTable这样的格式命名
--注意MAX-ACCESS的设置
--.1.3.6.1.4.1.73691.1.1
qosTable OBJECT-TYPE
	SYNTAX SEQUENCE OF QosEntry 
	MAX-ACCESS read-create
	STATUS current
	DESCRIPTION
		"专用承载列表"
	::= { qosTableRoot 1 }

--创建Entry对象，理解为Row，格式为xxxEntry，注意和定义的Entry对象名区别开
--注意INDEX一定要的
--.1.3.6.1.4.1.73691.1.1.1
qosEntry OBJECT-TYPE
	SYNTAX QosEntry 
	MAX-ACCESS read-create
	STATUS current
	DESCRIPTION
		""
	INDEX { qosIndex }
	::= { qosTable 1 }

--定义Entry对象，格式为xxxEntry，注意和创建Entry对象名区别开
--这里定义Index，RowStatus是必须的，其他的就按照需求自定义了
QosEntry::= SEQUENCE {
    	qosIndex 		Integer32,
    	WANDevice 		Integer32,
    	DLMaxRate 		Unsigned32,
    	qosRowStatus 	RowStatus
	}

--.1.3.6.1.4.1.73691.1.1.1.1
qosIndex OBJECT-TYPE
	SYNTAX Integer32 
	MAX-ACCESS read-create
	STATUS current
	DESCRIPTION
		"index"
	::= { qosEntry 1 }

--.1.3.6.1.4.1.73691.1.1.1.2
WANDevice OBJECT-TYPE
	SYNTAX Integer32 
	MAX-ACCESS read-create
	STATUS current
	DESCRIPTION
		"参数解释：广域网侧设备。取值范围：4 - 4 ,默认值：4"
	::= { qosEntry 2 }

--.1.3.6.1.4.1.73691.1.1.1.3
DLMaxRate OBJECT-TYPE
    SYNTAX Unsigned32
    MAX-ACCESS read-create
    STATUS current
    DESCRIPTION
    	"参数解释：下行最大速率。取值范围：0 - 262144,默认值：262144"
    ::= { qosEntry 3 }

--注意SYNTAX类型
--.1.3.6.1.4.1.73691.1.1.1.4
qosRowStatus OBJECT-TYPE
    SYNTAX RowStatus
    MAX-ACCESS read-create
    STATUS current
    DESCRIPTION
    	"rowStatus"
    ::= { qosEntry 4 }

END 
```

需要注意的地方已经在上面的MIB文件中注释了，可别看漏了哦。毕竟漏一些东西，也可以正常生成c文件，最后运行时候命令效果不对，根本不知道哪里出了问题。

## step2. 使用mib2c工具生成c文件

和上篇文章一样，不多赘述。输入指令，依据需求选择：

```shell
$ env MIBS="+/home/zzj/.snmp/mibs/QQ-MIB.txt" mib2c qosTableRoot
```

生成的c代码如下，我在代码中做好了注释：

```c
/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "qosTableRoot.h"

/** Initializes the qosTableRoot module */
void
init_qosTableRoot(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_qosTable();
}
  /*XXX 注释掉*/
  # Determine the first/last column names

/** Initialize the qosTable table by defining its contents and how it's structured */
void
initialize_table_qosTable(void)
{
    const oid qosTable_oid[] = {1,3,6,1,4,1,73691,1,1};
    const size_t qosTable_oid_len   = OID_LENGTH(qosTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("qosTableRoot:init", "initializing table qosTable\n"));

    reg = netsnmp_create_handler_registration(
              "qosTable",     qosTable_handler,
              qosTable_oid, qosTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: qosIndex */
                           0);
    table_info->min_column = COLUMN_QOSINDEX;
    table_info->max_column = COLUMN_QOSROWSTATUS;

    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = qosTable_get_first_data_point;
    iinfo->get_next_data_point  = qosTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;

    netsnmp_register_table_iterator( reg, iinfo );
    netsnmp_inject_handler_before( reg, 
        netsnmp_get_cache_handler(QOSTABLE_TIMEOUT,
                                  qosTable_load, qosTable_free,
                                  qosTable_oid, qosTable_oid_len),
            TABLE_ITERATOR_NAME);

    /* Initialise the contents of the table here */
    /* XXX 便于测试，你可以在这里初始化几行数据*/
}

    /* Typical data structure for a row entry */
struct qosTable_entry {
    /* Index values */
    long qosIndex;

    /* Column values */
    long qosIndex;
    long old_qosIndex;
    long WANDevice;
    long old_WANDevice;
    u_long DLMaxRate;
    u_long old_DLMaxRate;
    long qosRowStatus;

    /* Illustrate using a simple linked list */
    int   valid;
    struct qosTable_entry *next;
};

struct qosTable_entry  *qosTable_head;

/* create a new row in the (unsorted) table */
struct qosTable_entry *
qosTable_createEntry(
                 long  qosIndex,
        /*XXX 把参数补齐 */
                ) {
    struct qosTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct qosTable_entry);
    if (!entry)
        return NULL;

    entry->qosIndex = qosIndex;
    /*XXX 赋值 */
    entry->next = qosTable_head;
    qosTable_head = entry;
    return entry;
}

/* XXX 这里和下面调用参数匹配不上，修改使其一致即可*/
/* remove a row from the table */
void
qosTable_removeEntry( struct qosTable_entry *entry ) {
    struct qosTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = qosTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        qosTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

/* Example cache handling - set up linked list from a suitable file */
int
qosTable_load( netsnmp_cache *cache, void *vmagic ) {
    FILE *fp;
    struct qosTable_entry *this;
    char buf[STRMAX];

    /* The basic load routine template assumes that the data to
       be reported is held in a file - with one row of the file
       for each row of the table.
          If your data is available via a different API, you
       should amend this initial block (and the control of the
       'while' loop) accordingly.
          'XXX' marks where the template is incomplete and
       code will definitely need to be added. */

    //初始化操作，在这里读取文件，加载到table中
    fp = fopen( "/data/for/qosTable", "r" );
    if ( !fp ) {
        return -1;
    }
    while ( fgets( buf, STRMAX, fp )) {
        this = SNMP_MALLOC_TYPEDEF( struct qosTable_entry );
        /* XXX - Unpick 'buf' to extract the individual field values
                 and then populate the 'this' data structure with them */

        this->next = qosTable_head;
        qosTable_head = this;    /* Iterate helper is fine with unordered lists! */
    }
    fclose(fp);
    return 0;  /* OK */
}

void
qosTable_free( netsnmp_cache *cache, void *vmagic ) {
    struct qosTable_entry *this, *that;

    for ( this = qosTable_head; this; this=that ) {
        that = this->next;
        SNMP_FREE( this );   /* XXX - release any other internal resources */
    }
    qosTable_head = NULL;
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
qosTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = qosTable_head;
    return qosTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
qosTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct qosTable_entry *entry = (struct qosTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->qosIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}

//table_row和ret没有定义，自己定义一下吧
/** handles requests for the qosTable table */
int
qosTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct qosTable_entry          *table_entry;

    DEBUGMSGTL(("qosTableRoot:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct qosTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

            switch (table_info->colnum) {
            case COLUMN_QOSINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->qosIndex);
                break;
            case COLUMN_WANDEVICE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->WANDevice);
                break;
            case COLUMN_DLMAXRATE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_UNSIGNED,
                                            table_entry->DLMaxRate);
                break;
            case COLUMN_QOSROWSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->qosRowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            table_entry = (struct qosTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

            switch (table_info->colnum) {
            case COLUMN_QOSINDEX:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_WANDEVICE:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_DLMAXRATE:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_QOSROWSTATUS:
                ret = netsnmp_check_vb_rowstatus(request->requestvb,
                         (table_entry ? RS_ACTIVE : RS_NONEXISTENT ));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        for (request=requests; request; request=request->next) {
            table_entry = (struct qosTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

            switch (table_info->colnum) {
            case COLUMN_QOSROWSTATUS:
                switch (*request->requestvb->val.integer) {
        //按规范，一般是在RESERVE2这里做内存申请等操作，因此在这里创建了新的table_row
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    table_row = qosTable_createEntry(
                        , *table_info->indexes->val.integer
                        );
                    if (table_row) {
                        netsnmp_insert_iterator_context( request, table_row );
                    } else {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_RESOURCEUNAVAILABLE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
        break;

    case MODE_SET_FREE:
        for (request=requests; request; request=request->next) {
            table_entry = (struct qosTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

            switch (table_info->colnum) {
            case COLUMN_QOSROWSTATUS:
                switch (*request->requestvb->val.integer) {
        //valid属性是0，表示移除该行，这里怪怪的？可能因为是和SET_FREE有关吧
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        qosTable_removeEntry(table_data, table_row );
                    }
                }
            }
        }
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            table_entry = (struct qosTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

            switch (table_info->colnum) {
            case COLUMN_QOSINDEX:
                table_entry->old_qosIndex = table_entry->qosIndex;
                table_entry->qosIndex     = *request->requestvb->val.integer;
                break;
            case COLUMN_WANDEVICE:
                table_entry->old_WANDevice = table_entry->WANDevice;
                table_entry->WANDevice     = *request->requestvb->val.integer;
                break;
            case COLUMN_DLMAXRATE:
                table_entry->old_DLMaxRate = table_entry->DLMaxRate;
                table_entry->DLMaxRate     = *request->requestvb->val.integer;
                break;
            }
        }
        /* Check the internal consistency of an active row */
        for (request=requests; request; request=request->next) {
            table_entry = (struct qosTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

            switch (table_info->colnum) {
            case COLUMN_QOSROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_ACTIVE:
                case RS_CREATEANDGO:
            /* XXX 这两种状态对应使 指定的Row生效*/
                    if (/* XXX 异常判断*/) {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_INCONSISTENTVALUE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            table_entry = (struct qosTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

            switch (table_info->colnum) {
            case COLUMN_QOSINDEX:
                table_entry->qosIndex     = table_entry->old_qosIndex;
                table_entry->old_qosIndex = 0;
                break;
            case COLUMN_WANDEVICE:
                table_entry->WANDevice     = table_entry->old_WANDevice;
                table_entry->old_WANDevice = 0;
                break;
            case COLUMN_DLMAXRATE:
                table_entry->DLMaxRate     = table_entry->old_DLMaxRate;
                table_entry->old_DLMaxRate = 0;
                break;
            case COLUMN_QOSROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        qosTable_removeEntry(table_data, table_row );
                    }
                }
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        for (request=requests; request; request=request->next) {
            table_entry = (struct qosTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

            switch (table_info->colnum) {
            case COLUMN_QOSROWSTATUS:
                switch (*request->requestvb->val.integer) {
        //这里mib2c生成的已帮我们处理好，CREATEANDGO，valid直接是1，同时还把qosRowStatus设置为ACTIVE
                case RS_CREATEANDGO:
                    table_entry->valid = 1;
                    /* Fall-through */
                case RS_ACTIVE:
                    table_entry->qosRowStatus = RS_ACTIVE;
                    break;

        //创建但是不ACTIVE
                case RS_CREATEANDWAIT:
                    table_entry->valid = 1;
                    /* Fall-through */
                case RS_NOTINSERVICE:
                    table_entry->qosRowStatus = RS_NOTINSERVICE;
                    break;

                case RS_DESTROY:
                    qosTable_removeEntry(table_data, table_row );
                }
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}
```

对于RowStatus的几种状态的解释：

- active（1）:表明状态行是可用的
- notInService（2）:表明行存在但不可用
- notReady （3）:表明存在，但因为缺少必要的信息而不能用
- createAndGo （4）:由管理者设置，表明希望创建一个行并设置该行的状态列对象为active
- createAndWait（5）:由管理者设置，表明希望创建一个行，但不可用，从上面的代码看到，是被设置为了notInService
- destroy（6）:删除行

## step3. 编译、加载动态库

略

## step4. 调试

先snmpwalk看看情况：

```shell
$ snmpwalk -v2c -c sedwt localhost  .1.3.6.1.4.1
SNMPv2-SMI::enterprises.73691.1.1.1.1.1 = INTEGER: 1
SNMPv2-SMI::enterprises.73691.1.1.1.1.2 = INTEGER: 2
SNMPv2-SMI::enterprises.73691.1.1.1.2.1 = INTEGER: 4
SNMPv2-SMI::enterprises.73691.1.1.1.2.2 = INTEGER: 4
SNMPv2-SMI::enterprises.73691.1.1.1.3.1 = Gauge32: 276432
SNMPv2-SMI::enterprises.73691.1.1.1.3.2 = Gauge32: 276433
SNMPv2-SMI::enterprises.73691.1.1.1.4.1 = INTEGER: 0
SNMPv2-SMI::enterprises.73691.1.1.1.4.2 = INTEGER: 0
```

看来比较正常（本文在初始化中添加了2行数据），下面我们来添加一行数据：添加一行index为5的数据：

```shell
$ snmpset -v2c -c sedwt localhost  .1.3.6.1.4.1.73691.1.1.1.4.5 i 5
SNMPv2-SMI::enterprises.73691.1.1.1.4.5 = INTEGER: 5
$ snmpwalk -v2c -c sedwt localhost  .1.3.6.1.4.1
SNMPv2-SMI::enterprises.73691.1.1.1.1.1 = INTEGER: 1
SNMPv2-SMI::enterprises.73691.1.1.1.1.2 = INTEGER: 2
SNMPv2-SMI::enterprises.73691.1.1.1.1.5 = INTEGER: 5
SNMPv2-SMI::enterprises.73691.1.1.1.2.1 = INTEGER: 4
SNMPv2-SMI::enterprises.73691.1.1.1.2.2 = INTEGER: 4
SNMPv2-SMI::enterprises.73691.1.1.1.2.5 = INTEGER: 0
SNMPv2-SMI::enterprises.73691.1.1.1.3.1 = Gauge32: 276432
SNMPv2-SMI::enterprises.73691.1.1.1.3.2 = Gauge32: 276433
SNMPv2-SMI::enterprises.73691.1.1.1.3.5 = Gauge32: 0
SNMPv2-SMI::enterprises.73691.1.1.1.4.1 = INTEGER: 0
SNMPv2-SMI::enterprises.73691.1.1.1.4.2 = INTEGER: 0
SNMPv2-SMI::enterprises.73691.1.1.1.4.5 = INTEGER: 2
```

看到已经添加了一行数据，剩下分别set各属性值，最后设置RowStatus为active(1)就好了。
删除和修改都比较简单，就不贴过程了。

